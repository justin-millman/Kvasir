<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Kvasir</name>
    </assembly>
    <members>
        <member name="T:Kvasir.Schema.BasicField">
            <summary>
              An <see cref="T:Kvasir.Schema.IField"/> representing a single Field in a back-end database that has no implicit restrictions
              on the values that may be assumed by the Field's data.
            </summary>
            <remarks>
              <para>
                Within Kvasir, the role of any <see cref="T:Kvasir.Schema.IField"/> is to describe the attributes of a Field that are
                independent of the Table in which it appears. For example, the <see cref="T:Kvasir.Schema.IField"/> interface does not
                expose a column index, as this is a function of the Field's presence in a Table rather than an an inherent
                attribute of the Field itself. This also means that most constraints placed on a Field are considered
                extrinsic to the Field definition and are therefore not carried by the <see cref="T:Kvasir.Schema.IField"/> implementation.
              </para>
              <para>
                This pattern naturally extends to <see cref="T:Kvasir.Schema.BasicField"/>, which represents a Field where the set of
                allowed values is implicitly equal to the codomain of the Field's <see cref="P:Kvasir.Schema.IField.DataType"/>. This does
                not mean, however, that the set of allowed values for a <see cref="T:Kvasir.Schema.BasicField"/> cannot be contrained via
                a <c>CHECK</c> (or equivalent) constraint at the Table; such a constriant would be perfectly valid.
                However, a constraint in that vein would be fundamentally different than, for example, the inherent
                constraint placed upon a Field representing an enumeration; such a Field would not be represented within
                Kvasir by a <see cref="T:Kvasir.Schema.BasicField"/>.
              </para>
            </remarks>
            <seealso cref="T:Kvasir.Schema.EnumField"/>
        </member>
        <member name="P:Kvasir.Schema.BasicField.Name">
            <inheritdoc/>
        </member>
        <member name="P:Kvasir.Schema.BasicField.DataType">
            <inheritdoc/>
        </member>
        <member name="P:Kvasir.Schema.BasicField.Nullability">
            <inheritdoc/>
        </member>
        <member name="P:Kvasir.Schema.BasicField.DefaultValue">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.BasicField.#ctor(Kvasir.Schema.FieldName,Kvasir.Schema.DBType,Kvasir.Schema.IsNullable,Optional.Option{Kvasir.Schema.DBValue})">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.BasicField"/>.
            </summary>
            <param name="name">
              The <see cref="P:Kvasir.Schema.BasicField.Name"/> of the new <see cref="T:Kvasir.Schema.BasicField"/>.
            </param>
            <param name="dataType">
              The <see cref="P:Kvasir.Schema.BasicField.DataType"/> of the new <see cref="T:Kvasir.Schema.BasicField"/>.
            </param>
            <param name="nullability">
              The <see cref="P:Kvasir.Schema.BasicField.Nullability"/> of the new <see cref="T:Kvasir.Schema.BasicField"/>.
            </param>
            <param name="defaultValue">
              The <see cref="P:Kvasir.Schema.BasicField.DefaultValue"/> for the new <see cref="T:Kvasir.Schema.BasicField"/>.
            </param>
            <pre>
              <paramref name="dataType"/> is not <see cref="P:Kvasir.Schema.DBType.Enumeration"/>.
            </pre>
            <exception cref="T:System.ArgumentException">
              if <paramref name="nullability"/> is <see cref="F:Kvasir.Schema.IsNullable.No"/> but <paramref name="defaultValue"/> is
              a <c>SOME</c> instance wrapping <see cref="P:Kvasir.Schema.DBValue.NULL"/>
                --or--
              if <paramref name="defaultValue"/> is a <c>SOME</c> instance wrapping a <see cref="T:Kvasir.Schema.DBValue"/> that is
              <see cref="M:Kvasir.Schema.DBType.IsValidValue(Kvasir.Schema.DBValue)">not valid</see> for <paramref name="dataType"/>.
            </exception>
        </member>
        <member name="M:Kvasir.Schema.BasicField.Kvasir#Schema#IField#GenerateDeclaration(Kvasir.Transcription.Internal.IBuilderCollection)">
            <inheritdoc/>
        </member>
        <member name="T:Kvasir.Schema.CandidateKey">
            <summary>
              An <see cref="T:Kvasir.Schema.IKey"/> representing a <c>UNIQUE</c> constraint on a Table in a back-end relational database.
            </summary>
        </member>
        <member name="P:Kvasir.Schema.CandidateKey.Name">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.CandidateKey.#ctor">
            <summary>
              Constructs a new nameless <see cref="T:Kvasir.Schema.CandidateKey"/>.
            </summary>
        </member>
        <member name="M:Kvasir.Schema.CandidateKey.#ctor(Kvasir.Schema.KeyName)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.CandidateKey"/> with a name.
            </summary>
            <param name="name">
              The <see cref="P:Kvasir.Schema.CandidateKey.Name"/> of the new <see cref="T:Kvasir.Schema.CandidateKey"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.CandidateKey.AddField(Kvasir.Schema.IField)">
            <summary>
              Adds a new <see cref="T:Kvasir.Schema.IField"/> to this <see cref="T:Kvasir.Schema.CandidateKey"/>.
            </summary>
            <param name="field">
              The new <see cref="T:Kvasir.Schema.IField"/>.
            </param>
            <remarks>
              If <paramref name="field"/> has the same name (using as case-insensitive comparison) as any
              <see cref="T:Kvasir.Schema.IField"/> that is already part of this <see cref="T:Kvasir.Schema.CandidateKey"/>, no action is performed.
            </remarks>
        </member>
        <member name="M:Kvasir.Schema.CandidateKey.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.CandidateKey.Kvasir#Schema#IKey#GenerateDeclaration(Kvasir.Transcription.Internal.IBuilderCollection)">
            <inheritdoc/>
            <pre>
              At least one <see cref="T:Kvasir.Schema.IField"/> has been <see cref="M:Kvasir.Schema.CandidateKey.AddField(Kvasir.Schema.IField)">added</see> to this
              <see cref="T:Kvasir.Schema.CandidateKey"/>.
            </pre>
        </member>
        <member name="T:Kvasir.Schema.Constraints.AndClause">
            <summary>
              A compound <see cref="T:Kvasir.Schema.Constraints.Clause"/> that represents the logical conjunction between two constituent
              <see cref="T:Kvasir.Schema.Constraints.Clause">sub-clauses</see>.
            </summary>
        </member>
        <member name="P:Kvasir.Schema.Constraints.AndClause.LHS">
            <value>
              The left-hand portion of this <see cref="T:Kvasir.Schema.Constraints.AndClause"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.Constraints.AndClause.RHS">
            <value>
              The right-hand portion of this <see cref="T:Kvasir.Schema.Constraints.AndClause"/>.
            </value>
        </member>
        <member name="M:Kvasir.Schema.Constraints.AndClause.#ctor(Kvasir.Schema.Constraints.Clause,Kvasir.Schema.Constraints.Clause)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.Constraints.AndClause"/>.
            </summary>
            <param name="lhs">
              The <see cref="P:Kvasir.Schema.Constraints.AndClause.LHS">left-hand portion</see> of the new <see cref="T:Kvasir.Schema.Constraints.AndClause"/>.
            </param>
            <param name="rhs">
              The <see cref="P:Kvasir.Schema.Constraints.AndClause.RHS">right-hand portion</see> of the new <see cref="T:Kvasir.Schema.Constraints.AndClause"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.Constraints.AndClause.Negation">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.AndClause.GetDependentFields">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.AndClause.AddDeclarationTo(Kvasir.Transcription.Internal.IConstraintDeclBuilder)">
            <inheritdoc/>
        </member>
        <member name="T:Kvasir.Schema.Constraints.Clause">
            <summary>
              An abstract representation of a single clause in a potentially complex Boolean <c>CHECK</c> constraint.
            </summary>
        </member>
        <member name="M:Kvasir.Schema.Constraints.Clause.Negation">
            <summary>
              Creates a new <see cref="T:Kvasir.Schema.Constraints.Clause"/> that represents the logical negation of this <see cref="T:Kvasir.Schema.Constraints.Clause"/>.
            </summary>
            <returns>
              A new <see cref="T:Kvasir.Schema.Constraints.Clause"/> that represents the logical negation of this <see cref="T:Kvasir.Schema.Constraints.Clause"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.Constraints.Clause.And(Kvasir.Schema.Constraints.Clause)">
            <summary>
              Creates a compound clause that represents the logical conjunction (i.e. <c>AND</c>) of this
              <see cref="T:Kvasir.Schema.Constraints.Clause"/> and another.
            </summary>
            <param name="rhs">
              The <see cref="T:Kvasir.Schema.Constraints.Clause"/> with which to conjunct this one.
            </param>
            <returns>
              A compound clause that represents the logical conjunction of this <see cref="T:Kvasir.Schema.Constraints.Clause"/> and
              <paramref name="rhs"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.Constraints.Clause.Or(Kvasir.Schema.Constraints.Clause)">
            <summary>
              Creates a compound clause that represents the logical disjunction (i.e. <c>AND</c>) of this
              <see cref="T:Kvasir.Schema.Constraints.Clause"/> and another.
            </summary>
            <param name="rhs">
              The <see cref="T:Kvasir.Schema.Constraints.Clause"/> with which to disjunct this one.
            </param>
            <returns>
              A compound clause that represents the logical disjunction of this <see cref="T:Kvasir.Schema.Constraints.Clause"/> and
              <paramref name="rhs"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.Constraints.Clause.Xor(Kvasir.Schema.Constraints.Clause)">
            <summary>
              Creates a compound clause that represents the logical exclusive disjunctino (i.e. <c>XOR</c>) of this
              <see cref="T:Kvasir.Schema.Constraints.Clause"/> and another.
            </summary>
            <param name="rhs">
              The <see cref="T:Kvasir.Schema.Constraints.Clause"/> with which to exclusively disjunct this one.
            </param>
            <returns>
              A compound clause that represents the logical disjunction of this <see cref="T:Kvasir.Schema.Constraints.Clause"/> and
              <paramref name="rhs"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.Constraints.Clause.GetDependentFields">
            <summary>
              Gets a collection of the <see cref="T:Kvasir.Schema.IField">Fields</see> on whose value this <see cref="T:Kvasir.Schema.Constraints.Clause"/> is at
              least partially dependent.
            </summary>
            <returns>
              A collection of the <see cref="T:Kvasir.Schema.IField">Fields</see> on whose value this <see cref="T:Kvasir.Schema.Constraints.Clause"/> is at least
              partially dependent. The order of the Fields is not defined, and Fields may be (but are not necessarily)
              duplicated.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.Constraints.Clause.AddDeclarationTo(Kvasir.Transcription.Internal.IConstraintDeclBuilder)">
            <summary>
              Appends the declaratory SQL for this <see cref="T:Kvasir.Schema.Constraints.Clause"/> onto the in-progress declaration managed by
              an existing <see cref="T:Kvasir.Transcription.Internal.IConstraintDeclBuilder"/>.
            </summary>
            <param name="builder">
              The <see cref="T:Kvasir.Transcription.Internal.IConstraintDeclBuilder"/> to which to add the declaration for this <see cref="T:Kvasir.Schema.Constraints.Clause"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.Constraints.Clause.IfThen(Kvasir.Schema.Constraints.Clause,Kvasir.Schema.Constraints.Clause)">
            <summary>
              Creates a compound clause that represents a unidirectional logical implication (i.e. <c>if X then Y</c>)
              between two constituent <see cref="T:Kvasir.Schema.Constraints.Clause">Clauses</see>.
            </summary>
            <param name="predicate">
              The predicate <see cref="T:Kvasir.Schema.Constraints.Clause"/> of the logical implication, i.e. the <c>X</c> in <c>if X then Y</c>.
            </param>
            <param name="consequent">
              The consequent <see cref="T:Kvasir.Schema.Constraints.Clause"/> of the logical implication, i.e. the <c>Y</c> in <c>if X then Y</c>.
            </param>
            <returns>
              A compound clause that represents the logical implication of "if <paramref name="predicate"/> then
              <paramref name="consequent"/>."
            </returns>
        </member>
        <member name="M:Kvasir.Schema.Constraints.Clause.Iff(Kvasir.Schema.Constraints.Clause,Kvasir.Schema.Constraints.Clause)">
            <summary>
              Creates a compound clause that represents a bidrectional logical implication (i.e. <c>X if and only if Y
              </c>) between two constituent <see cref="T:Kvasir.Schema.Constraints.Clause">Clauses</see>.
            </summary>
            <param name="lhs">
              The left-hand <see cref="T:Kvasir.Schema.Constraints.Clause"/> of the logical implication, i.e. the <c>X</c> in <c>X if and only if
              Y</c>, which is logically interchangeable with the right-hand side.
            </param>
            <param name="rhs">
              The right-hand <see cref="T:Kvasir.Schema.Constraints.Clause"/> of the logical implication, i.e. the <c>Y</c> in <c>X if and only if
              Y</c>, which is logically interchangeable with the left-hand side.
            </param>
            <returns>
              A compound clause that represents the logical implication of "<paramref name="lhs"/> if and only if
              <paramref name="rhs"/>."
            </returns>
        </member>
        <member name="T:Kvasir.Schema.Constraints.ConstantValueClause">
            <summary>
              A non-compound <see cref="T:Kvasir.Schema.Constraints.Clause"/> that expresses a condition on the value of an expression relative to a
              single constant.
            </summary>
        </member>
        <member name="P:Kvasir.Schema.Constraints.ConstantValueClause.LHS">
            <value>
              The left-hand expression of this <see cref="T:Kvasir.Schema.Constraints.ConstantValueClause"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.Constraints.ConstantValueClause.Operator">
            <value>
              The operator of this <see cref="T:Kvasir.Schema.Constraints.ConstantValueClause"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.Constraints.ConstantValueClause.RHS">
            <value>
              The right-hand expression of this <see cref="T:Kvasir.Schema.Constraints.ConstantValueClause"/>.
            </value>
        </member>
        <member name="M:Kvasir.Schema.Constraints.ConstantValueClause.#ctor(Kvasir.Schema.Constraints.FieldExpression,Kvasir.Schema.Constraints.ComparisonOperator,Kvasir.Schema.DBValue)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.Constraints.ConstantValueClause"/>.
            </summary>
            <param name="lhs">
              The <see cref="P:Kvasir.Schema.Constraints.ConstantValueClause.LHS">left-hand expression</see> of the new <see cref="T:Kvasir.Schema.Constraints.ConstantValueClause"/>.
            </param>
            <param name="op">
              The <see cref="P:Kvasir.Schema.Constraints.ConstantValueClause.Operator"/> of the new <see cref="T:Kvasir.Schema.Constraints.ConstantValueClause"/>.
            </param>
            <param name="rhs">
              The <see cref="P:Kvasir.Schema.Constraints.ConstantValueClause.RHS">right-hand expression</see> of the new <see cref="T:Kvasir.Schema.Constraints.ConstantValueClause"/>.
            </param>
            <pre>
              <paramref name="rhs"/> is not <see cref="P:Kvasir.Schema.DBValue.NULL"/>.
            </pre>
            <exception cref="T:System.ArgumentException">
              if <paramref name="rhs"/> is <see cref="M:Kvasir.Schema.DBType.IsValidValue(Kvasir.Schema.DBValue)">not valid</see> for the
              <see cref="P:Kvasir.Schema.Constraints.FieldExpression.DataType"/> of <paramref name="lhs"/>.
            </exception>
        </member>
        <member name="M:Kvasir.Schema.Constraints.ConstantValueClause.Negation">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.ConstantValueClause.GetDependentFields">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.ConstantValueClause.AddDeclarationTo(Kvasir.Transcription.Internal.IConstraintDeclBuilder)">
            <inheritdoc/>
        </member>
        <member name="T:Kvasir.Schema.Constraints.CrossFieldValueConstraint">
            <summary>
              A non-compound <see cref="T:Kvasir.Schema.Constraints.Clause"/> that expresses a condition on the value of an expression relative to a
              the value of another expression.
            </summary>
        </member>
        <member name="P:Kvasir.Schema.Constraints.CrossFieldValueConstraint.LHS">
            <value>
              The left-hand expression of this <see cref="T:Kvasir.Schema.Constraints.CrossFieldValueConstraint"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.Constraints.CrossFieldValueConstraint.Operator">
            <value>
              The operator of this <see cref="T:Kvasir.Schema.Constraints.CrossFieldValueConstraint"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.Constraints.CrossFieldValueConstraint.RHS">
            <value>
              The right-hand expression of this <see cref="T:Kvasir.Schema.Constraints.CrossFieldValueConstraint"/>.
            </value>
        </member>
        <member name="M:Kvasir.Schema.Constraints.CrossFieldValueConstraint.#ctor(Kvasir.Schema.Constraints.FieldExpression,Kvasir.Schema.Constraints.ComparisonOperator,Kvasir.Schema.Constraints.FieldExpression)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.Constraints.CrossFieldValueConstraint"/>.
            </summary>
            <param name="lhs">
              The <see cref="P:Kvasir.Schema.Constraints.CrossFieldValueConstraint.LHS">left-hand expression</see> of the new <see cref="T:Kvasir.Schema.Constraints.CrossFieldValueConstraint"/>.
            </param>
            <param name="op">
              The <see cref="P:Kvasir.Schema.Constraints.CrossFieldValueConstraint.Operator"/> of the new <see cref="T:Kvasir.Schema.Constraints.CrossFieldValueConstraint"/>.
            </param>
            <param name="rhs">
              The <see cref="P:Kvasir.Schema.Constraints.CrossFieldValueConstraint.RHS">right-hand expression</see> of the new <see cref="T:Kvasir.Schema.Constraints.CrossFieldValueConstraint"/>.
            </param>
            <exception cref="T:System.ArgumentException">
              if the <see cref="P:Kvasir.Schema.Constraints.FieldExpression.DataType"/> of <paramref name="lhs"/> and <paramref name="rhs"/> are
              not equal.
            </exception>
        </member>
        <member name="M:Kvasir.Schema.Constraints.CrossFieldValueConstraint.Negation">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.CrossFieldValueConstraint.GetDependentFields">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.CrossFieldValueConstraint.AddDeclarationTo(Kvasir.Transcription.Internal.IConstraintDeclBuilder)">
            <inheritdoc/>
        </member>
        <member name="T:Kvasir.Schema.Constraints.FieldExpression">
            <summary>
              A representation of an expression involving the value of an <see cref="T:Kvasir.Schema.IField"/> that may form part of a
              <see cref="T:Kvasir.Schema.Constraints.Clause"/>.
            </summary>
        </member>
        <member name="P:Kvasir.Schema.Constraints.FieldExpression.Function">
            <value>
              The <see cref="T:Kvasir.Schema.Constraints.FieldFunction"/> applied to the value of <see cref="P:Kvasir.Schema.Constraints.FieldExpression.Field"/> to form this
              <see cref="T:Kvasir.Schema.Constraints.FieldExpression"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.Constraints.FieldExpression.Field">
            <value>
              The <see cref="T:Kvasir.Schema.IField"/> of this <see cref="T:Kvasir.Schema.Constraints.FieldExpression"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.Constraints.FieldExpression.DataType">
            <value>
              The data type of this <see cref="T:Kvasir.Schema.Constraints.FieldExpression"/>, accounting for the possible transformation applied
              by <see cref="P:Kvasir.Schema.Constraints.FieldExpression.Function"/>.
            </value>
        </member>
        <member name="M:Kvasir.Schema.Constraints.FieldExpression.#ctor(Kvasir.Schema.IField)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.Constraints.FieldExpression"/> with no value transformation function.
            </summary>
            <param name="field">
              The <see cref="P:Kvasir.Schema.Constraints.FieldExpression.Field"/> of the new <see cref="T:Kvasir.Schema.Constraints.FieldExpression"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.Constraints.FieldExpression.#ctor(Kvasir.Schema.Constraints.FieldFunction,Kvasir.Schema.IField)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.Constraints.FieldExpression"/> that includes a value transformation function.
            </summary>
            <param name="function">
              The <see cref="P:Kvasir.Schema.Constraints.FieldExpression.Function"/> of the new <see cref="T:Kvasir.Schema.Constraints.FieldExpression"/>.
            </param>
            <param name="field">
              The <see cref="P:Kvasir.Schema.Constraints.FieldExpression.Field"/> of the new <see cref="T:Kvasir.Schema.Constraints.FieldExpression"/>.
            </param>
            <exception cref="T:System.ArgumentException">
              if <paramref name="function"/> is incompatible with the <see cref="P:Kvasir.Schema.IField.DataType"/> of
              <paramref name="field"/>.
            </exception>
        </member>
        <member name="T:Kvasir.Schema.Constraints.FieldFunction">
            <summary>
              A representation of the functions that can be applied to the value of a Field as part of a
              <see cref="T:Kvasir.Schema.Constraints.FieldExpression"/>.
            </summary>
        </member>
        <member name="F:Kvasir.Schema.Constraints.FieldFunction.Length">
            <summary>The function that takes the length of a string</summary>
        </member>
        <member name="T:Kvasir.Schema.Constraints.InclusionClause">
            <summary>
              A non-compound <see cref="T:Kvasir.Schema.Constraints.Clause"/> that expresses a condition on the value of an expression relative to a
              list of constants.
            </summary>
        </member>
        <member name="P:Kvasir.Schema.Constraints.InclusionClause.LHS">
            <value>
              The left-hand expression of this <see cref="T:Kvasir.Schema.Constraints.InclusionClause"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.Constraints.InclusionClause.Operator">
            <value>
              The operator of this <see cref="T:Kvasir.Schema.Constraints.InclusionClause"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.Constraints.InclusionClause.RHS">
            <value>
              The right-hand expression of this <see cref="T:Kvasir.Schema.Constraints.InclusionClause"/>.
            </value>
        </member>
        <member name="M:Kvasir.Schema.Constraints.InclusionClause.#ctor(Kvasir.Schema.Constraints.FieldExpression,Kvasir.Schema.Constraints.InclusionOperator,System.Collections.Generic.IEnumerable{Kvasir.Schema.DBValue})">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.Constraints.InclusionClause"/>.
            </summary>
            <param name="lhs">
              The <see cref="P:Kvasir.Schema.Constraints.InclusionClause.LHS">left-hand expression</see> of the new <see cref="T:Kvasir.Schema.Constraints.InclusionClause"/>.
            </param>
            <param name="op">
              The <see cref="P:Kvasir.Schema.Constraints.InclusionClause.Operator"/> of the new <see cref="T:Kvasir.Schema.Constraints.InclusionClause"/>.
            </param>
            <param name="rhs">
              The <see cref="P:Kvasir.Schema.Constraints.InclusionClause.RHS">right-hand expression</see> of the new <see cref="T:Kvasir.Schema.Constraints.InclusionClause"/>.
            </param>
            <pre>
              <paramref name="rhs"/> is not empty
                --and--
              None of the <see cref="T:Kvasir.Schema.DBValue">DBValues</see> in <paramref name="rhs"/> is <see cref="P:Kvasir.Schema.DBValue.NULL"/>.
            </pre>
            <exception cref="T:System.ArgumentException">
              if any of the <see cref="T:Kvasir.Schema.DBValue">DBValues</see> in <paramref name="rhs"/> is
              <see cref="M:Kvasir.Schema.DBType.IsValidValue(Kvasir.Schema.DBValue)">not valid</see> for the <see cref="P:Kvasir.Schema.Constraints.FieldExpression.DataType"/>
              of <paramref name="lhs"/>.
            </exception>
        </member>
        <member name="M:Kvasir.Schema.Constraints.InclusionClause.Negation">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.InclusionClause.GetDependentFields">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.InclusionClause.AddDeclarationTo(Kvasir.Transcription.Internal.IConstraintDeclBuilder)">
            <inheritdoc/>
        </member>
        <member name="T:Kvasir.Schema.Constraints.NullityClause">
            <summary>
              A non-compound <see cref="T:Kvasir.Schema.Constraints.Clause"/> that expresses a condition on the nullity (<i>not</i> nullability) of an
              <see cref="T:Kvasir.Schema.IField"/>.
            </summary>
        </member>
        <member name="P:Kvasir.Schema.Constraints.NullityClause.LHS">
            <value>
              The left-hand expression of this <see cref="T:Kvasir.Schema.Constraints.NullityClause"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.Constraints.NullityClause.Operator">
            <value>
              The operator of this <see cref="T:Kvasir.Schema.Constraints.NullityClause"/>.
            </value>
        </member>
        <member name="M:Kvasir.Schema.Constraints.NullityClause.#ctor(Kvasir.Schema.IField,Kvasir.Schema.Constraints.NullityOperator)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.Constraints.NullityClause"/>.
            </summary>
            <param name="field">
              The <see cref="P:Kvasir.Schema.Constraints.NullityClause.LHS">field on which</see> the new <see cref="T:Kvasir.Schema.Constraints.NullityClause"/> is predicated.
            </param>
            <param name="op">
              The <see cref="P:Kvasir.Schema.Constraints.NullityClause.Operator"/> of the new <see cref="T:Kvasir.Schema.Constraints.NullityClause"/>.
            </param>
            <exception cref="T:System.ArgumentException">
              if <paramref name="field"/> is not nullable.
            </exception>
        </member>
        <member name="M:Kvasir.Schema.Constraints.NullityClause.Negation">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.NullityClause.GetDependentFields">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.NullityClause.AddDeclarationTo(Kvasir.Transcription.Internal.IConstraintDeclBuilder)">
            <inheritdoc/>
        </member>
        <member name="T:Kvasir.Schema.Constraints.ComparisonOperator">
            <summary>
              A representation of the logical comparison operators
            </summary>
        </member>
        <member name="F:Kvasir.Schema.Constraints.ComparisonOperator.Equal">
            <summary>The <c>==</c> comparison operator</summary>
        </member>
        <member name="F:Kvasir.Schema.Constraints.ComparisonOperator.NotEqual">
            <summary>The <c>!=</c> comparison operator</summary>
        </member>
        <member name="F:Kvasir.Schema.Constraints.ComparisonOperator.LessThan">
            <summary>The <c>&lt;</c> comparison operator</summary>
        </member>
        <member name="F:Kvasir.Schema.Constraints.ComparisonOperator.GreaterThan">
            <summary>The <c>&gt;</c> comparison operator</summary>
        </member>
        <member name="F:Kvasir.Schema.Constraints.ComparisonOperator.LessThanOrEqual">
            <summary>The <c>&lt;=</c> comparison operator</summary>
        </member>
        <member name="F:Kvasir.Schema.Constraints.ComparisonOperator.GreaterThanOrEqual">
            <summary>The <c>&gt;=</c> comparison operator</summary>
        </member>
        <member name="T:Kvasir.Schema.Constraints.InclusionOperator">
            <summary>
              A representation of the SQL inclusion operators
            </summary>
        </member>
        <member name="F:Kvasir.Schema.Constraints.InclusionOperator.In">
            <summary>The logical inclusion operator</summary>
        </member>
        <member name="F:Kvasir.Schema.Constraints.InclusionOperator.NotIn">
            <summary>The logical exclusion operator</summary>
        </member>
        <member name="T:Kvasir.Schema.Constraints.NullityOperator">
            <summary>
              A representation of the SQL nullity operators
            </summary>
        </member>
        <member name="F:Kvasir.Schema.Constraints.NullityOperator.IsNull">
            <summary>The logical is-NULL operator</summary>
        </member>
        <member name="F:Kvasir.Schema.Constraints.NullityOperator.IsNotNull">
            <summary>The logical is-not-NULL operator</summary>
        </member>
        <member name="T:Kvasir.Schema.Constraints.OperatorExtensions">
            <summary>
              A collection of extension methods that operate on Constrant operators.
            </summary>
        </member>
        <member name="M:Kvasir.Schema.Constraints.OperatorExtensions.Negation(Kvasir.Schema.Constraints.ComparisonOperator)">
            <summary>
              Produces the negation of a <see cref="T:Kvasir.Schema.Constraints.ComparisonOperator"/>.
            </summary>
            <param name="op">
              The <see cref="T:Kvasir.Schema.Constraints.ComparisonOperator"/> to negate.
            </param>
            <returns>
              The negation of <paramref name="op"/>; that is, the operator <c>~</c> such that if
              <c>X <paramref name="op"/> Y</c> is <see langword="true"/> then <c>X ~ Y</c> is guaranteed to be
              <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Kvasir.Schema.Constraints.OrClause">
            <summary>
              A compound <see cref="T:Kvasir.Schema.Constraints.Clause"/> that represents the logical disjunction between two constituent
              <see cref="T:Kvasir.Schema.Constraints.Clause">sub-clauses</see>.
            </summary>
        </member>
        <member name="P:Kvasir.Schema.Constraints.OrClause.LHS">
            <value>
              The left-hand portion of this <see cref="T:Kvasir.Schema.Constraints.OrClause"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.Constraints.OrClause.RHS">
            <value>
              The right-hand portion of this <see cref="T:Kvasir.Schema.Constraints.OrClause"/>.
            </value>
        </member>
        <member name="M:Kvasir.Schema.Constraints.OrClause.#ctor(Kvasir.Schema.Constraints.Clause,Kvasir.Schema.Constraints.Clause)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.Constraints.OrClause"/>.
            </summary>
            <param name="lhs">
              The <see cref="P:Kvasir.Schema.Constraints.OrClause.LHS">left-hand portion</see> of the new <see cref="T:Kvasir.Schema.Constraints.OrClause"/>.
            </param>
            <param name="rhs">
              The <see cref="P:Kvasir.Schema.Constraints.OrClause.RHS">right-hand portion</see> of the new <see cref="T:Kvasir.Schema.Constraints.OrClause"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.Constraints.OrClause.Negation">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.OrClause.GetDependentFields">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.Constraints.OrClause.AddDeclarationTo(Kvasir.Transcription.Internal.IConstraintDeclBuilder)">
            <inheritdoc/>
        </member>
        <member name="T:Kvasir.Schema.CheckConstraint">
            <summary>
              An arbitrary <c>CHECK</c> constraint that applies to the values of one or more Fields.
            </summary>
        </member>
        <member name="P:Kvasir.Schema.CheckConstraint.Name">
            <summary>
              The name of this <see cref="T:Kvasir.Schema.CheckConstraint"/>.
            </summary>
        </member>
        <member name="M:Kvasir.Schema.CheckConstraint.#ctor(Kvasir.Schema.Constraints.Clause)">
            <summary>
              Constructs a new nameless <see cref="T:Kvasir.Schema.CheckConstraint"/>.
            </summary>
            <param name="condition">
              The condition body of the new <see cref="T:Kvasir.Schema.CheckConstraint"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.CheckConstraint.#ctor(Kvasir.Schema.ConstraintName,Kvasir.Schema.Constraints.Clause)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.CheckConstraint"/> with a name.
            </summary>
            <param name="name">
              The <see cref="P:Kvasir.Schema.CheckConstraint.Name"/> of the new <see cref="T:Kvasir.Schema.CheckConstraint"/>.
            </param>
            <param name="condition">
              The condition body of the new <see cref="T:Kvasir.Schema.CheckConstraint"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.CheckConstraint.GetDependentFields">
            <summary>
              Gets a collection of the <see cref="T:Kvasir.Schema.IField">Fields</see> on whose value this
              <see cref="T:Kvasir.Schema.CheckConstraint"/> is at least partially dependent.
            </summary>
            <returns>
              A collection of the <see cref="T:Kvasir.Schema.IField">Fields</see> on whose value this <see cref="T:Kvasir.Schema.CheckConstraint"/> is
              at least partially dependent. The order of the Fields is not defined, and Fields may be (but are not
              necessarily) duplicated.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.CheckConstraint.GenerateDeclaration(Kvasir.Transcription.Internal.IBuilderCollection)">
            <summary>
              Generates a <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/> that declares this <see cref="T:Kvasir.Schema.CheckConstraint"/> as part of a
              <c>CREATE TABLE</c> statement.
            </summary>
            <param name="syntax">
              The <see cref="T:Kvasir.Transcription.Internal.IBuilderCollection"/> exposing the <see cref="T:Kvasir.Transcription.Internal.IDeclBuilder">IDeclBuilders</see> that this
              <see cref="T:Kvasir.Schema.CheckConstraint"/> should use to generate its declaratory <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/>.
            </param>
            <returns>
              A <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/> that declares this <see cref="T:Kvasir.Schema.CheckConstraint"/> within a <c>CREATE TABLE</c>
              statement according to the syntax rules of <paramref name="syntax"/>.
            </returns>
        </member>
        <member name="T:Kvasir.Schema.ConstraintName">
            <summary>
              The name of an <see cref="T:Kvasir.Schema.CheckConstraint"/>.
            </summary>
        </member>
        <member name="M:Kvasir.Schema.ConstraintName.#ctor(System.String)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.ConstraintName"/>.
            </summary>
            <param name="name">
              The name. Any leading and trailing whitespace is trimmed.
            </param>
            <exception cref="T:System.ArgumentException">
              if <paramref name="name"/> is the empty string or consists only of whitespace characters.
            </exception>
        </member>
        <member name="T:Kvasir.Schema.DBType">
            <summary>
              An implementation-agnostic representation of a data type for a Field in a back-end database.
            </summary>
            <remarks>
              <para>
                A <see cref="T:Kvasir.Schema.DBType"/> instance represents the semantics of a data type without specifying the actual
                storage mechanism or data type metadata. These semantics are intentionally generalized, allowing for a
                single <see cref="T:Kvasir.Schema.DBType"/> to represent data types across a variety of back-end database providers.
                Because different providers may offer different restrictions on data types (such as precision for floating
                point numbers or maximum lengths for strings), these auxiliaries are excluded from the content of a
                <see cref="T:Kvasir.Schema.DBType"/>.
              </para>
              <para>
                Functionally, the <see cref="T:Kvasir.Schema.DBType"/> struct operates much like an enumeration, in that users are limited
                to the set of predefined instances that are accessed through the <c>DBType</c> pseduo-namespace. Unlike
                native enumerations, however, <see cref="T:Kvasir.Schema.DBType"/> instances cannot interoperate with numeric primitives
                and cannot be used directly in a <c>switch</c> statement (though they <i>can</i> be used in pattern
                matching expressions). Additionally, the <see cref="T:Kvasir.Schema.DBType"/> struct provides a series of member functions
                for executing various queries.
              </para>
              <para>
                One thing that is notably absent from the specification carried by a <see cref="T:Kvasir.Schema.DBType"/> is any indication
                of nullability. Within Kvasir, nullability is a feature of Fields, and is thus fully omitted from the
                <see cref="T:Kvasir.Schema.DBType"/> struct.
              </para>
            </remarks>
        </member>
        <member name="P:Kvasir.Schema.DBType.Boolean">
            <value>
              The representation of a Boolean value (i.e. <c>true</c>/<c>false</c>).
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.Character">
            <value>
              The representation of a single UTF-16 character point.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.Int8">
            <value>
              The representation of an <c>8</c>-bit signed integer.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.Int16">
            <value>
              The representation of a <c>16</c>-bit signed integer.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.Int32">
            <value>
              The representation of a <c>32</c>-bit signed integer.
            </value>
            <remarks>
              <see cref="P:Kvasir.Schema.DBType.Int32"/> is guaranteed to be equal to a default constructed <see cref="T:Kvasir.Schema.DBType"/> instance.
            </remarks>
        </member>
        <member name="P:Kvasir.Schema.DBType.Int64">
            <value>
              The representation of a <c>64</c>-bit signed integer.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.UInt8">
            <value>
              The representation of an <c>8</c>-bit unsigned integer.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.UInt16">
            <value>
              The representation of a <c>16</c>-bit unsigned integer.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.UInt32">
            <value>
              The representation of a <c>32</c>-bit unsigned integer.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.UInt64">
            <value>
              The representation of a <c>64</c>-bit unsigned integer.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.Single">
            <value>
              The representation of a single-precision floating point number.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.Double">
            <value>
              The representation of a double-precision floating point number.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.Decimal">
            <value>
              The representation of a decimal floating point number.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.DateTime">
            <value>
              The representation of a timestamp consisting of a calendar date and a time.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.Text">
            <value>
              The representation of a variable-length string of characters.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.Guid">
            <value>
              The representation of a globally unique identifier.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBType.Enumeration">
            <value>
              The representation of an enumeration, i.e. a restricted set of integral or string options.
            </value>
        </member>
        <member name="M:Kvasir.Schema.DBType.IsSupported(System.Type)">
            <summary>
              Determines if a particular CLR <see cref="T:System.Type"/> is supported by Kvasir.
            </summary>
            <param name="clrType">
              The CLR <see cref="T:System.Type"/>.
            </param>
            <returns>
              <see langword="true"/> if there is a <see cref="T:Kvasir.Schema.DBType"/> instance that matches the semantics of
              <paramref name="clrType"/>; otherwise, <see langword="false"/>.
            </returns>
            <seealso cref="M:Kvasir.Schema.DBType.Lookup(System.Type)"/>
        </member>
        <member name="M:Kvasir.Schema.DBType.Lookup(System.Type)">
            <summary>
              Looks up the <see cref="T:Kvasir.Schema.DBType"/> instance that matches the semantics of a particular CLR
              <see cref="T:System.Type"/>.
            </summary>
            <param name="clrType">
              The CLR <see cref="T:System.Type"/>.
            </param>
            <returns>
              The <see cref="T:Kvasir.Schema.DBType"/> instance that matches the semantics of <paramref name="clrType"/>. This is the
              <see cref="T:Kvasir.Schema.DBType"/> of a Field whose .NET source values are instances of <paramref name="clrType"/>.
            </returns>
            <exception cref="T:System.ArgumentException">
              If there is no <see cref="T:Kvasir.Schema.DBType"/> instance that matches the semantics of <paramref name="clrType"/>.
            </exception>
            <seealso cref="M:Kvasir.Schema.DBType.IsSupported(System.Type)"/>
        </member>
        <member name="M:Kvasir.Schema.DBType.IsValidValue(Kvasir.Schema.DBValue)">
            <summary>
              Determines if a particular <see cref="T:Kvasir.Schema.DBValue"/> would be a valid value for a Field whose data type is
              this <see cref="T:Kvasir.Schema.DBType"/>.
            </summary>
            <param name="value">
              The <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="value"/> is <see cref="P:Kvasir.Schema.DBValue.NULL"/> or if this
              <see cref="T:Kvasir.Schema.DBType"/> matches the semantics of the type of datum wrapped by <paramref name="value"/>;
              otherwise, <see langword="false"/>.
            </returns>
            <remarks>
              <para>
                Within Kvasir, enums are represented as string values; this is the format by which the data is actually
                transacted with the back-end database. For this reason, a <see cref="T:Kvasir.Schema.DBValue"/> cannot actually wrap a
                CLR enumerator. As such, <see cref="M:Kvasir.Schema.DBType.IsValidValue(Kvasir.Schema.DBValue)"/> will return <see langword="true"/> if
                <paramref name="value"/> wraps a <see cref="T:System.String"/> and the current <see cref="T:Kvasir.Schema.DBType"/> is
                <i>either</i> <see cref="P:Kvasir.Schema.DBType.Text"/> or <see cref="P:Kvasir.Schema.DBType.Enumeration"/>. However, the <see cref="M:Kvasir.Schema.DBType.Lookup(System.Type)"/>
                method will <i>always</i> return <see cref="P:Kvasir.Schema.DBType.Text"/> when the input <see cref="T:System.Type"/> is
                <see cref="T:System.String"/>.
              </para>
              <para>
                Additionally, <see cref="M:Kvasir.Schema.DBType.IsValidValue(Kvasir.Schema.DBValue)"/> does not account for any restrictions on a particular
                realization of an abstract data type, such as range limits, valid enumerators, or nullability: just
                because <see cref="M:Kvasir.Schema.DBType.IsValidValue(Kvasir.Schema.DBValue)"/> returns <see langword="true"/> does not mean that the value
                can actually be stored in a Field whose data type is the current <see cref="T:Kvasir.Schema.DBType"/>.
              </para>
            </remarks>
        </member>
        <member name="M:Kvasir.Schema.DBType.Equals(Kvasir.Schema.DBType)">
            <summary>
              Determines whether this <see cref="T:Kvasir.Schema.DBType"/> is equal to another <see cref="T:Kvasir.Schema.DBType"/>.
            </summary>
            <param name="rhs">
              The <see cref="T:Kvasir.Schema.DBType"/> against which to compare this one for equality.
            </param>
            <returns>
              <see langword="true"/> if this <see cref="T:Kvasir.Schema.DBType"/> is equal to <paramref name="rhs"/>; otherwise,
              <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.DBType.Equals(System.Object)">
            <summary>
              Determines whether this <see cref="T:Kvasir.Schema.DBType"/> is equal to another <see cref="T:System.Object"/>.
            </summary>
            <param name="rhs">
              The <see cref="T:System.Object"/> against which to compare this one for equality.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="rhs"/> is a <see cref="T:Kvasir.Schema.DBType"/> that is equal to this
              <see cref="T:Kvasir.Schema.DBType"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.DBType.GetHashCode">
            <summary>
              Produces the hash code for this <see cref="T:Kvasir.Schema.DBType"/>.
            </summary>
            <returns>
              A <c>32</c>-bit signed integer that is the hash code for this <see cref="T:Kvasir.Schema.DBType"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.DBType.op_Equality(Kvasir.Schema.DBType,Kvasir.Schema.DBType)">
            <summary>
              Determines if two <see cref="T:Kvasir.Schema.DBType">DBTypes</see> are equal.
            </summary>
            <param name="lhs">
              The first <see cref="T:Kvasir.Schema.DBType"/>.
            </param>
            <param name="rhs">
              The second <see cref="T:Kvasir.Schema.DBType"/>.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="lhs"/> is equal to <paramref name="rhs"/>; otherwise,
              <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.DBType.op_Inequality(Kvasir.Schema.DBType,Kvasir.Schema.DBType)">
            <summary>
              Determiens if two <see cref="T:Kvasir.Schema.DBType">DBTypes</see> are not equal.
            </summary>
            <param name="lhs">
              The first <see cref="T:Kvasir.Schema.DBType"/>.
            </param>
            <param name="rhs">
              The second <see cref="T:Kvasir.Schema.DBType"/>.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="lhs"/> is not equal to <paramref name="rhs"/>; otherwise,
              <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.DBType.#cctor">
            <summary>
              Initializes the static state of the <see cref="T:Kvasir.Schema.DBType"/> struct.
            </summary>
        </member>
        <member name="M:Kvasir.Schema.DBType.#ctor(System.Byte)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBType"/>.
            </summary>
            <param name="id">
              The identifier for the new <see cref="T:Kvasir.Schema.DBType"/>.
            </param>
            <pre>
              <paramref name="id"/> is in the range <c>[0, 16]</c>.
            </pre>
        </member>
        <member name="M:Kvasir.Schema.DBType.Normalize(System.Type)">
            <summary>
              Nomralizes a a CLR <see cref="T:System.Type"/> for internal lookup.
            </summary>
            <param name="clrType">
              The CLR <see cref="T:System.Type"/> to normalize.
            </param>
            <returns>
              The normalization of <paramref name="clrType"/>.
            </returns>
        </member>
        <member name="T:Kvasir.Schema.DBValue">
            <summary>
              A thin wrapper around a CLR object that can be stored in a back-end relational database.
            </summary>
            <remarks>
              <para>
                The <see cref="T:Kvasir.Schema.DBValue"/> class is intended to provide an abstraction over the generalized CLR
                <see  cref="T:System.Object"/> for use in contexts where compile-time type information is not available. The
                advantage to using a <see cref="T:Kvasir.Schema.DBValue"/> in APIs rather than <see cref="T:System.Object"/> is the guarantee that a
                <see cref="T:Kvasir.Schema.DBValue"/> only ever wraps an objec that can validly be stored into a database, whereas an
                <see cref="T:System.Object"/> could feasibly hold an object of any type. Additionally, the wrapped value is never
                a <see langword="null"/> reference: a sentinel value is used to indicate <see langword="null"/>, mitigating
                the need for verbose checks.
              </para>
              <para>
                The strong typing afforded by CLR <see cref="T:System.Enum">enums</see> is lost when the enumerator values are
                stored in a back-end relational database. Some providers afford value checking, either through an explicit
                <c>enum</c> data type or via <c>CHECK</c> constraints; however, even in these cases, the actual storage is
                generally an integer or a string. For this reason, an instance of <see cref="T:Kvasir.Schema.DBValue"/> will never wrap a
                CLR enumerator: it is the responsibility of the user to convert the CLR object into the corresponding
                database object, be it an integer or string or other supported type.
              </para>
              <para>
                The same general logic applies to any transformations applied between the CLR domain and the database
                domain. The <see cref="T:Kvasir.Schema.DBValue"/> class is intended to exactly wrap the object that is stored, and as such
                it is the responsibility of the user to apply any necessary transforms prior to creating the
                <see cref="T:Kvasir.Schema.DBValue"/> object.
              </para>
              <para>
                Because of the possibility that a <see cref="T:Kvasir.Schema.DBValue"/> instance wraps a sentinel indicating
                <see langword="null"/>, it is not strictly possible to determine the <see cref="T:Kvasir.Schema.DBType"/> of a particular
                instance. To check if a <see cref="T:Kvasir.Schema.DBValue"/> is valid for a Field of a particular <see cref="T:Kvasir.Schema.DBType"/>,
                use the <see cref="M:Kvasir.Schema.DBType.IsValidValue(Kvasir.Schema.DBValue)"/> query method.
              </para>
            </remarks>
        </member>
        <member name="P:Kvasir.Schema.DBValue.Datum">
            <value>
              The <see cref="T:System.Object"/> wrapped by this <see cref="T:Kvasir.Schema.DBValue"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.DBValue.NULL">
            <value>
              A sentinel <see cref="T:Kvasir.Schema.DBValue"/> instance representing the CLR concept of <see langword="null"/>.
            </value>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.Boolean)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.Boolean"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.Boolean"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.Byte)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.Byte"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.Byte"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.SByte)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.SByte"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.SByte"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.UInt16)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.UInt16"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.UInt16"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.Int16)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.Int16"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.Int16"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.UInt32)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.UInt32"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.Int32)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.Int32"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.Int32"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.UInt64)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.UInt64"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.UInt64"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.Int64)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.Int64"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.Int64"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.Single)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.Single"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.Single"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.Double)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.Double"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.Double"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.Decimal)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.Decimal"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.Decimal"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.DateTime)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.DateTime"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.DateTime"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.Char)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.Char"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.Char"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.String)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.String"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.String"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.Guid)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps a <see cref="T:System.Guid"/>.
            </summary>
            <param name="value">
              The <see cref="T:System.Guid"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.DBValue.Create(System.Object)">
            <summary>
              Creates a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps an <see cref="T:System.Object"/> whose compile-time type is not
              known.
            </summary>
            <param name="value">
              The <see cref="T:System.Object"/> to be wrapped by the new <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
            <exception cref="T:System.ArgumentException">
              if the CLR type of <paramref name="value"/> is not one for which there is an available strongly typed
              constructor, and <paramref name="value"/> cannot be implicitly converted to such a type.
            </exception>
        </member>
        <member name="M:Kvasir.Schema.DBValue.Equals(Kvasir.Schema.DBValue)">
            <summary>
              Determines whether this <see cref="T:Kvasir.Schema.DBValue"/> is equal to another <see cref="T:Kvasir.Schema.DBValue"/>.
            </summary>
            <param name="rhs">
              The <see cref="T:Kvasir.Schema.DBValue"/> against which to compare this one for equality.
            </param>
            <returns>
              <see langword="true"/> if this <see cref="T:Kvasir.Schema.DBValue"/> is equal to <paramref name="rhs"/>; otherwise,
              <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.DBValue.Equals(System.Object)">
            <summary>
              Determines whether this <see cref="T:Kvasir.Schema.DBValue"/> is equal to another <see cref="T:System.Object"/>.
            </summary>
            <param name="rhs">
              The <see cref="T:System.Object"/> against which to compare this one for equality.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="rhs"/> is a <see cref="T:Kvasir.Schema.DBValue"/> that is equal to this
              <see cref="T:Kvasir.Schema.DBValue"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.DBValue.GetHashCode">
            <summary>
              Produces the hash code for this <see cref="T:Kvasir.Schema.DBValue"/>.
            </summary>
            <returns>
              A <c>32</c>-bit signed integer that is the hash code for this <see cref="T:Kvasir.Schema.DBValue"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.DBValue.ToString">
            <summary>
              Produces a string representation of this <see cref="T:Kvasir.Schema.DBValue"/>.
            </summary>
            <returns>
              A string representation of this <see cref="T:Kvasir.Schema.DBValue"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.DBValue.op_Equality(Kvasir.Schema.DBValue,Kvasir.Schema.DBValue)">
            <summary>
              Determines if two <see cref="T:Kvasir.Schema.DBValue">DBValues</see> are equal.
            </summary>
            <param name="lhs">
              The first <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
            <param name="rhs">
              The second <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="lhs"/> is equal to <paramref name="rhs"/>; otherwise,
              <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.DBValue.op_Inequality(Kvasir.Schema.DBValue,Kvasir.Schema.DBValue)">
            <summary>
              Determiens if two <see cref="T:Kvasir.Schema.DBValue">DBValues</see> are not equal.
            </summary>
            <param name="lhs">
              The first <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
            <param name="rhs">
              The second <see cref="T:Kvasir.Schema.DBValue"/>.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="lhs"/> is not equal to <paramref name="rhs"/>; otherwise,
              <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.DBValue.#ctor(System.DBNull)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.DBValue"/> that wraps the <c>NULL</c> sentinel.
            </summary>
        </member>
        <member name="T:Kvasir.Schema.EnumField">
            <summary>
              An <see cref="T:Kvasir.Schema.IField"/> representing a single Field in a back-end database that has an implicit restriction
              on the values that may be assumed by the Field's data.
            </summary>
            <remarks>
              <para>
                Within Kvasir, the role of any <see cref="T:Kvasir.Schema.IField"/> is to describe the attributes of a Field that are
                independent of the Table in which it appears. For example, the <see cref="T:Kvasir.Schema.IField"/> interface does not
                expose a column index, as this is a function of the Field's presence in a Table rather than an an inherent
                attribute of the Field itself. This also means that most constraints placed on a Field are considered
                extrinsic to the Field definition and are therefore not carried by the <see cref="T:Kvasir.Schema.IField"/> implementation.
              </para>
              <para>
                This pattern naturally extends to <see cref="T:Kvasir.Schema.EnumField"/>, which represents a Field where the data is one
                of a strict set of allowed text values. This is functionally equivalent to a <see cref="T:Kvasir.Schema.BasicField"/> of
                type <see cref="P:Kvasir.Schema.DBType.Text"/> with an appropriate inclusivity constraint; however, the difference is that
                an <see cref="T:Kvasir.Schema.EnumField"/> bakes the restriction into the nature of the Field itself rather than as a later
                add-on realized by the owning Table. It is generally unnecessary to further restrict the values allowed for
                an <see cref="T:Kvasir.Schema.EnumField"/>, though doing so is still legal and may have its niche uses.
              </para>
            </remarks>
            <seealso cref="T:Kvasir.Schema.BasicField"/>
        </member>
        <member name="P:Kvasir.Schema.EnumField.Name">
            <inheritdoc/>
        </member>
        <member name="P:Kvasir.Schema.EnumField.DataType">
            <inheritdoc/>
        </member>
        <member name="P:Kvasir.Schema.EnumField.Nullability">
            <inheritdoc/>
        </member>
        <member name="P:Kvasir.Schema.EnumField.DefaultValue">
            <inheritdoc/>
        </member>
        <member name="P:Kvasir.Schema.EnumField.Enumerators">
            <value>
              The values that this <see cref="T:Kvasir.Schema.EnumField"/> is allowed to take on.
            </value>
        </member>
        <member name="M:Kvasir.Schema.EnumField.#ctor(Kvasir.Schema.FieldName,Kvasir.Schema.IsNullable,Optional.Option{Kvasir.Schema.DBValue},System.Collections.Generic.IEnumerable{Kvasir.Schema.DBValue})">
            Constructs a new <see cref="T:Kvasir.Schema.EnumField"/>.
            <param name="name">
              The <see cref="P:Kvasir.Schema.EnumField.Name"/> of the new <see cref="T:Kvasir.Schema.EnumField"/>.
            </param>
            <param name="nullability">
              The <see cref="P:Kvasir.Schema.EnumField.Nullability"/> of the new <see cref="T:Kvasir.Schema.EnumField"/>.
            </param>
            <param name="defaultValue">
              The <see cref="P:Kvasir.Schema.EnumField.DefaultValue"/> for the new <see cref="T:Kvasir.Schema.EnumField"/>.
            </param>
            <param name="enumerators">
              The allowed values for the new <see cref="T:Kvasir.Schema.EnumField"/>.
            </param>
            <pre>
              None of the values in <paramref name="enumerators"/> is <see cref="P:Kvasir.Schema.DBValue.NULL"/>
                --and--
              Each value in <paramref name="enumerators"/> is <see cref="M:Kvasir.Schema.DBType.IsValidValue(Kvasir.Schema.DBValue)">valid</see> for
              <see cref="P:Kvasir.Schema.DBType.Enumeration"/>.
            </pre>
            <exception cref="T:System.ArgumentException">
              if <paramref name="nullability"/> is <see cref="F:Kvasir.Schema.IsNullable.No"/> but <paramref name="defaultValue"/> is
              a <c>SOME</c> instance wrapping <see cref="P:Kvasir.Schema.DBValue.NULL"/>
                --or--
              if <paramref name="enumerators"/> is empty
                --or--
              if <paramref name="defaultValue"/> is a <c>SOME</c> instance wrapping a <see cref="T:Kvasir.Schema.DBValue"/> that is
              not <see cref="P:Kvasir.Schema.DBValue.NULL"/> and is not one of the values in <paramref name="enumerators"/>
            </exception>
        </member>
        <member name="M:Kvasir.Schema.EnumField.Kvasir#Schema#IField#GenerateDeclaration(Kvasir.Transcription.Internal.IBuilderCollection)">
            <inheritdoc/>
        </member>
        <member name="T:Kvasir.Schema.IField">
            <summary>
              The interface representing a single Field in a back-end relational database.
            </summary>
            <remarks>
              This interface can only be implemented by classes within the <see cref="N:Kvasir"/> assembly.
            </remarks>
        </member>
        <member name="P:Kvasir.Schema.IField.Name">
            <value>
              The name of this <see cref="T:Kvasir.Schema.IField"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.IField.DataType">
            <value>
              The <see cref="T:Kvasir.Schema.DBType"/> of this <see cref="T:Kvasir.Schema.IField"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.IField.Nullability">
            <value>
              Whether or not <c>NULL</c> is an acceptable value for this <see cref="T:Kvasir.Schema.IField"/>.
            </value>
        </member>
        <member name="P:Kvasir.Schema.IField.DefaultValue">
            <value>
              The default value for this <see cref="T:Kvasir.Schema.IField"/>.
            </value>
            <post>
              <see cref="P:Kvasir.Schema.IField.DefaultValue"/> is a <c>SOME</c> instance wrapping <see cref="P:Kvasir.Schema.DBValue.NULL"/> only if
              <see cref="T:Kvasir.Schema.IsNullable"/> is <see cref="F:Kvasir.Schema.IsNullable.Yes"/>
                --and--
              if <see cref="P:Kvasir.Schema.IField.DefaultValue"/> iis a <c>SOME</c> instance, the value that it wraps is a
              <see cref="M:Kvasir.Schema.DBType.IsValidValue(Kvasir.Schema.DBValue)">valid value</see> for <see cref="P:Kvasir.Schema.IField.DataType"/>.
            </post>
            <remarks>
              A <c>NONE</c> instance indicates that this <see cref="T:Kvasir.Schema.IField"/> does not have a default value, while a
              <c>SOME</c> instance indicates that a default value does exist. Notably, a <c>SOME</c> instance wrapping
              <see cref="P:Kvasir.Schema.DBValue.NULL"/> denotes the presence of a default with this specific datum value rather than
              the absence of a default value.
            </remarks>
        </member>
        <member name="M:Kvasir.Schema.IField.GenerateDeclaration(Kvasir.Transcription.Internal.IBuilderCollection)">
            <summary>
              Generates a <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/> that declares this <see cref="T:Kvasir.Schema.IField"/> as part of a <c>CREATE
              TABLE</c> statement.
            </summary>
            <param name="syntax">
              The <see cref="T:Kvasir.Transcription.Internal.IBuilderCollection"/> exposing the <see cref="T:Kvasir.Transcription.Internal.IDeclBuilder">IDeclBuilders</see> that this
              <see cref="T:Kvasir.Schema.IField"/> should use to generate its declaratory <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/>.
            </param>
            <returns>
              A <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/> that declares this <see cref="T:Kvasir.Schema.IField"/> within a <c>CREATE TABLE</c>
              statement according to the syntax rules of <paramref name="syntax"/>.
            </returns>
        </member>
        <member name="T:Kvasir.Schema.FieldName">
            <summary>
              The name of an <see cref="T:Kvasir.Schema.IField"/>.
            </summary>
        </member>
        <member name="M:Kvasir.Schema.FieldName.#ctor(System.String)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.FieldName"/>.
            </summary>
            <param name="name">
              The name. Any leading and trailing whitespace is trimmed.
            </param>
            <exception cref="T:System.ArgumentException">
              if <paramref name="name"/> is the empty string or consists only of whitespace characters.
            </exception>
        </member>
        <member name="T:Kvasir.Schema.IsNullable">
            <summary>
              A strongly typed binary value representing the nullability of an <see cref="T:Kvasir.Schema.IField"/>
            </summary>
        </member>
        <member name="F:Kvasir.Schema.IsNullable.No">
            <summary>Indicates that an <see cref="T:Kvasir.Schema.IField"/> is not nullable</summary>
        </member>
        <member name="F:Kvasir.Schema.IsNullable.Yes">
            <summary>Indicates that an <see cref="T:Kvasir.Schema.IField"/> is nullable</summary>
        </member>
        <member name="T:Kvasir.Schema.IKey">
            <summary>
              The interface representing a single Key in a back-end relational database.
            </summary>
            <remarks>
              This interface can only be implemented by classes within the <see cref="N:Kvasir"/> assembly.
            </remarks>
        </member>
        <member name="P:Kvasir.Schema.IKey.Name">
            <value>
              The name of this <see cref="T:Kvasir.Schema.IKey"/>.
            </value>
        </member>
        <member name="M:Kvasir.Schema.IKey.GetEnumerator">
            <summary>
              Produces an enumerator that iterates over the set of <see cref="T:Kvasir.Schema.IField">Fields</see> that comprise this
              <see cref="T:Kvasir.Schema.IKey"/>. The order of iteration is not defined but is guaranteed to be the same for repeated
              iterations.
            </summary>
            <returns>
              An enumerator that iterates over the set of <see cref="T:Kvasir.Schema.IField">Fields</see> that comprise this
              <see cref="T:Kvasir.Schema.IKey"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Schema.IKey.GenerateDeclaration(Kvasir.Transcription.Internal.IBuilderCollection)">
            <summary>
              Generates a <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/> that declares this <see cref="T:Kvasir.Schema.IKey"/> as part of a <c>CREATE
              TABLE</c> statement.
            </summary>
            <param name="syntax">
              The <see cref="T:Kvasir.Transcription.Internal.IBuilderCollection"/> exposing the <see cref="T:Kvasir.Transcription.Internal.IDeclBuilder">IDeclBuilders</see> that this
              <see cref="T:Kvasir.Schema.IKey"/> should use to generate its declaratory <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/>.
            </param>
            <returns>
              A <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/> that declares this <see cref="T:Kvasir.Schema.IKey"/> within a <c>CREATE TABLE</c>
              statement according to the syntax rules of <paramref name="syntax"/>.
            </returns>
        </member>
        <member name="T:Kvasir.Schema.KeyName">
            <summary>
              The name of an <see cref="T:Kvasir.Schema.IKey"/>.
            </summary>
        </member>
        <member name="M:Kvasir.Schema.KeyName.#ctor(System.String)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.KeyName"/>.
            </summary>
            <param name="name">
              The name. Any leading and trailing whitespace is trimmed.
            </param>
            <exception cref="T:System.ArgumentException">
              if <paramref name="name"/> is the empty string or consists only of whitespace characters.
            </exception>
        </member>
        <member name="T:Kvasir.Schema.PrimaryKey">
            <summary>
              An <see cref="T:Kvasir.Schema.IKey"/> representing a <c>PRIMARY KEY</c> constraint on a Table in a back-end relational
              database.
            </summary>
        </member>
        <member name="P:Kvasir.Schema.PrimaryKey.Name">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.PrimaryKey.#ctor">
            <summary>
              Constructs a new nameless <see cref="T:Kvasir.Schema.CandidateKey"/>.
            </summary>
        </member>
        <member name="M:Kvasir.Schema.PrimaryKey.#ctor(Kvasir.Schema.KeyName)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Schema.CandidateKey"/> with a name.
            </summary>
            <param name="name">
              The <see cref="P:Kvasir.Schema.PrimaryKey.Name"/> of the new <see cref="T:Kvasir.Schema.CandidateKey"/>.
            </param>
        </member>
        <member name="M:Kvasir.Schema.PrimaryKey.AddField(Kvasir.Schema.IField)">
            <summary>
              Adds a new <see cref="T:Kvasir.Schema.IField"/> to this <see cref="T:Kvasir.Schema.CandidateKey"/>.
            </summary>
            <param name="field">
              The new <see cref="T:Kvasir.Schema.IField"/>.
            </param>
            <exception cref="T:System.ArgumentException">
              if <paramref name="field"/> is <see cref="P:Kvasir.Schema.IField.Nullability">nullable</see>.
            </exception>
            <remarks>
              If <paramref name="field"/> has the same name (using as case-insensitive comparison) as any
              <see cref="T:Kvasir.Schema.IField"/> that is already part of this <see cref="T:Kvasir.Schema.CandidateKey"/>, no action is performed.
            </remarks>
        </member>
        <member name="M:Kvasir.Schema.PrimaryKey.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Kvasir.Schema.PrimaryKey.Kvasir#Schema#IKey#GenerateDeclaration(Kvasir.Transcription.Internal.IBuilderCollection)">
            <inheritdoc/>
            <pre>
              At least one <see cref="T:Kvasir.Schema.IField"/> has been <see cref="M:Kvasir.Schema.PrimaryKey.AddField(Kvasir.Schema.IField)">added</see> to this
              <see cref="T:Kvasir.Schema.PrimaryKey"/>.
            </pre>
        </member>
        <member name="T:Kvasir.Transcription.Internal.IBuilderCollection">
            <summary>
              A collection of <see cref="T:Kvasir.Transcription.Internal.IDeclBuilder">IDeclBuilders</see> for generating the declaratory
              <see cref="T:Kvasir.Transcription.Internal.SqlSnippet">SqlSnippets</see> of various schema components with a provider-unified syntax.
            </summary>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IBuilderCollection.FieldDeclBuilder">
            <summary>
              Exposes an <see cref="T:Kvasir.Transcription.Internal.IFieldDeclBuilder"/> using the syntax of this <see cref="T:Kvasir.Transcription.Internal.IBuilderCollection"/>
              that is in its initial (or "reset") state.
            </summary>
            <returns>
              An <see cref="T:Kvasir.Transcription.Internal.IFieldDeclBuilder"/> in its initial (or "reset") state that uses the rules of this
              <see cref="T:Kvasir.Transcription.Internal.IBuilderCollection"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IBuilderCollection.ConstraintDeclBuilder">
            <summary>
              Exposes an <see cref="T:Kvasir.Transcription.Internal.IConstraintDeclBuilder"/> using the syntax of this <see cref="T:Kvasir.Transcription.Internal.IBuilderCollection"/>
              that is in its initial (or "reset") state.
            </summary>
            <returns>
              An <see cref="T:Kvasir.Transcription.Internal.IConstraintDeclBuilder"/> in its initial (or "reset") state that uses the rules of this
              <see cref="T:Kvasir.Transcription.Internal.IBuilderCollection"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IBuilderCollection.KeyDeclBuilder">
            <summary>
              Exposes an <see cref="T:Kvasir.Transcription.Internal.IKeyDeclBuilder"/> using the syntax of this <see cref="T:Kvasir.Transcription.Internal.IBuilderCollection"/> that
              is in its initial (or "reset") state.
            </summary>
            <returns>
              An <see cref="T:Kvasir.Transcription.Internal.IKeyDeclBuilder"/> in its initial (or "reset") state that uses the rules of this
              <see cref="T:Kvasir.Transcription.Internal.IBuilderCollection"/>.
            </returns>
        </member>
        <member name="T:Kvasir.Transcription.Internal.IConstraintDeclBuilder">
            <summary>
              An <see cref="T:Kvasir.Transcription.Internal.IDeclBuilder"/> that builds declaratory <see cref="T:Kvasir.Transcription.Internal.SqlSnippet">SqlSnippets</see> for non-Key
              Constraints.
            </summary>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IConstraintDeclBuilder.SetName(Kvasir.Schema.ConstraintName)">
            <summary>
              Sets the name of the Constraint whose declaration is represented by the current state of this
              <see cref="T:Kvasir.Transcription.Internal.IConstraintDeclBuilder"/>.
            </summary>
            <param name="name">
              The name.
            </param>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IConstraintDeclBuilder.NewAndClause">
            <summary>
              Begins a new <c>AND</c> clause in the current constraint declaration.
            </summary>
            <returns>
              A handle that, when disposed of, terminates the new <c>AND</c> clause that has been started.
            </returns>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IConstraintDeclBuilder.NewOrClause">
            <summary>
              Begins a new <c>OR</c> clause in the current constraint declaration.
            </summary>
            <returns>
              A handle that, when disposed of, terminates the new <c>OR</c> clause that has been started.
            </returns>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IConstraintDeclBuilder.AddCheck(Kvasir.Schema.Constraints.NullityClause)">
            <summary>
              Adds a new <see cref="T:Kvasir.Schema.Constraints.NullityClause"/> to the current constraint declaration.
            </summary>
            <param name="clause">
              The <see cref="T:Kvasir.Schema.Constraints.NullityClause"/> to add to the constraint declaration.
            </param>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IConstraintDeclBuilder.AddCheck(Kvasir.Schema.Constraints.InclusionClause)">
            <summary>
              Adds a new <see cref="T:Kvasir.Schema.Constraints.InclusionClause"/> to the current constraint declaration.
            </summary>
            <param name="clause">
              The <see cref="T:Kvasir.Schema.Constraints.InclusionClause"/> to add to the constraint declaration.
            </param>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IConstraintDeclBuilder.AddCheck(Kvasir.Schema.Constraints.ConstantValueClause)">
            <summary>
              Adds a new <see cref="T:Kvasir.Schema.Constraints.ConstantValueClause"/> to the current constraint declaration.
            </summary>
            <param name="clause">
              The <see cref="T:Kvasir.Schema.Constraints.ConstantValueClause"/> to add to the constraint declaration.
            </param>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IConstraintDeclBuilder.AddCheck(Kvasir.Schema.Constraints.CrossFieldValueConstraint)">
            <summary>
              Adds a new <see cref="T:Kvasir.Schema.Constraints.CrossFieldValueConstraint"/> to the current constraint declaration.
            </summary>
            <param name="clause">
              The <see cref="T:Kvasir.Schema.Constraints.CrossFieldValueConstraint"/> to add to the constraint declaration.
            </param>
        </member>
        <member name="T:Kvasir.Transcription.Internal.IDeclBuilder">
            <summary>
              The interface for a builder that produces <see cref="T:Kvasir.Transcription.Internal.SqlSnippet">SqlSnippets</see> that can be used in a DDL
              statement.
            </summary>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IDeclBuilder.Build">
            <summary>
              Builds the declaratory <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/> based on the current state of this
              <see cref="T:Kvasir.Transcription.Internal.IDeclBuilder"/>.
            </summary>
            <returns>
              A <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/> that reflects the current state of this <see cref="T:Kvasir.Transcription.Internal.IDeclBuilder"/>.
            </returns>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IDeclBuilder.Reset">
            <summary>
              Resets the current state of this <see cref="T:Kvasir.Transcription.Internal.IDeclBuilder"/>.
            </summary>
        </member>
        <member name="T:Kvasir.Transcription.Internal.IFieldDeclBuilder">
            <summary>
              An <see cref="T:Kvasir.Transcription.Internal.IDeclBuilder"/> that builds declaratory <see cref="T:Kvasir.Transcription.Internal.SqlSnippet">SqlSnippets</see> for Fields.
            </summary>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IFieldDeclBuilder.SetName(Kvasir.Schema.FieldName)">
            <summary>
              Sets the name of the Field whose declaration is represented by the current state of this
              <see cref="T:Kvasir.Transcription.Internal.IFieldDeclBuilder"/>.
            </summary>
            <param name="name">
              The name.
            </param>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IFieldDeclBuilder.SetDataType(Kvasir.Schema.DBType)">
            <summary>
              Sets the data type of the Field whose declaration is represented by the current state of this
              <see cref="T:Kvasir.Transcription.Internal.IFieldDeclBuilder"/>.
            </summary>
            <param name="dataType">
              The data type.
            </param>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IFieldDeclBuilder.SetNullability(Kvasir.Schema.IsNullable)">
            <summary>
              Sets the nullability of the Field whose declaration is represented by the current state of this
              <see cref="T:Kvasir.Transcription.Internal.IFieldDeclBuilder"/>.
            </summary>
            <param name="nullability">
              The nullability.
            </param>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IFieldDeclBuilder.SetDefaultValue(Kvasir.Schema.DBValue)">
            <summary>
              Sets the default value of the Field whose declaration is represented by the current state of this
              <see cref="T:Kvasir.Transcription.Internal.IFieldDeclBuilder"/>.
            </summary>
            <param name="defaultValue">
              The default value.
            </param>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IFieldDeclBuilder.SetAllowedValues(System.Collections.Generic.IEnumerable{Kvasir.Schema.DBValue})">
            <summary>
              Sets the list of values that are allowed for the Field whose declaration is represented by the current
              state of this <see cref="T:Kvasir.Transcription.Internal.IFieldDeclBuilder"/>.
            </summary>
            <param name="enumerators">
              The list of alloed values.
            </param>
        </member>
        <member name="T:Kvasir.Transcription.Internal.IKeyDeclBuilder">
            <summary>
              An <see cref="T:Kvasir.Transcription.Internal.IDeclBuilder"/> that builds declaratory <see cref="T:Kvasir.Transcription.Internal.SqlSnippet">SqlSnippets</see> for internal
              (as opposed to foreign) Keys.
            </summary>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IKeyDeclBuilder.SetName(Kvasir.Schema.KeyName)">
            <summary>
              Sets the name of the Key whose declaration is represented by the current state of this
              <see cref="T:Kvasir.Transcription.Internal.IKeyDeclBuilder"/>.
            </summary>
            <param name="name">
              The name.
            </param>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IKeyDeclBuilder.AddField(Kvasir.Schema.FieldName)">
            <summary>
              Adds an <see cref="T:Kvasir.Schema.IField"/> by name to the collection of Fields that make up the Key whose declaration
              is represented by the current state of this <see cref="T:Kvasir.Transcription.Internal.IKeyDeclBuilder"/>.
            </summary>
            <param name="fieldName">
              The name of the Field.
            </param>
        </member>
        <member name="M:Kvasir.Transcription.Internal.IKeyDeclBuilder.SetAsPrimary">
            <summary>
              Sets the Key whose declaration is represented by the current state of this <see cref="T:Kvasir.Transcription.Internal.IKeyDeclBuilder"/>
              as a <c>PRIMARY KEY</c>.
            </summary>
        </member>
        <member name="T:Kvasir.Transcription.Internal.SqlSnippet">
            <summary>
              A snippet of SQL that declares a complete or partial schema component according to some provider-specific
              syntax rules.
            </summary>
        </member>
        <member name="M:Kvasir.Transcription.Internal.SqlSnippet.#ctor(System.String)">
            <summary>
              Constructs a new <see cref="T:Kvasir.Transcription.Internal.SqlSnippet"/>.
            </summary>
            <param name="sql">
              The SQL snippet in string form, properly formatted and with any necesary character or substrings already
              escaped.
            </param>
            <pre>
              <paramref name="sql"/> contains at least one non-whitespace character.
            </pre>
        </member>
        <member name="T:Cybele.ConceptString`1">
            <summary>
              A strongly typed <see cref="T:System.String"/> class that represents a specific application or library domain concept.
            </summary>
            <remarks>
              <para>
                The <see cref="T:Cybele.ConceptString`1"/> class is an abstract base class intended to assist in modeling
                application or library domain concepts whose intrinsic data form is a sequence of characters. This utility
                is designed to afford developers an expressive and type-safe way to design APIs (for both internal and/or
                external use) that do not suffer from "primitive obsession." This utility can thusly be used to
                disambiguate APIs that would otherwise expect a sequence of <see cref="T:System.String">strings</see>, provide
                return type clarity, and/or encapsulate more intricate domain validation logic.
              </para>
              <para>
                To prevent escaping out of the strong typing afforded by <see cref="T:Cybele.ConceptString`1"/>, there is
                neither an implicit conversion to nor one from <see cref="T:System.String"/>. To interoperate with APIs expecting a
                raw <see cref="T:System.String"/> instance, a one-way <i>explicit</i> conversion operator is available. It is
                recommended that this conversion be used only at API boundaries rather than within the domain of a single
                application or library. A separate one-way implicit conversion from <see cref="T:Cybele.ConceptString`1"/>
                to <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;char&gt;</see> is provided for easy interoperation with the
                .NET standard library.
              </para>
              <para>
                As with <see cref="T:System.String"/>, <see cref="T:Cybele.ConceptString`1"/> offers native equality operations, both
                in the form of the <see cref="T:System.IEquatable`1"/> interface and standard binary operators. The default
                behavior of the <see cref="M:System.IEquatable`1.Equals(`0)"/> method is to evaluate using an ordinal,
                case-sensitive comparison; however, this method is intentionally <see langword="virtual"/>, affording
                derived types the opportunity to provide a more appropriate implementation. This same pattern extends to
                ordering comparisons through the <see cref="T:System.IComparable`1"/> interface. As per usual, a
                <see langword="null"/> <see cref="T:Cybele.ConceptString`1"/> compares equal/equivalent to other
                <see langword="null"/> instances and compares less than any non-<see langword="null"/> ones.
              </para>
              <para>
                Aside from equality and ordering comparisons, the <see cref="T:Cybele.ConceptString`1"/> class does not
                provide much in the way of an API. There are no modification methods, no concatenation operator, no static
                comparison overloads, etc. The minimal API provided by <see cref="T:Cybele.ConceptString`1"/> is intended to
                be the API that is universally desired; concatenation may not make sense for all domain concepts, so it is
                not provided by default. Derived classes are encouraged to implement additional member functions that
                harmonize with the particular domain concept(s) being modeled.
              </para>
            </remarks>
        </member>
        <member name="P:Cybele.ConceptString`1.Length">
            <value>
              The number of characters in this <see cref="T:Cybele.ConceptString`1"/>.
            </value>
        </member>
        <member name="P:Cybele.ConceptString`1.Item(System.Int32)">
            <value>
              The character in this <see cref="T:Cybele.ConceptString`1"/> at a particular position.
            </value>
            <param name="index">
              The <c>0</c>-based index of the target character.
            </param>
            <exception cref="T:System.IndexOutOfRangeException">
              if <c><paramref name="index"/> &lt; 0</c> or <c><paramref name="index"/> &gt;= <see cref="P:Cybele.ConceptString`1.Length"/></c>.
            </exception>
        </member>
        <member name="P:Cybele.ConceptString`1.View">
            <value>
              A read-only, non-allocating view into the contents of this <see cref="T:Cybele.ConceptString`1"/>.
            </value>
        </member>
        <member name="M:Cybele.ConceptString`1.op_Implicit(Cybele.ConceptString{`0})~System.ReadOnlySpan{System.Char}">
            <summary>
              Converts a <see cref="T:Cybele.ConceptString`1"/> into a
              <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;char&gt;</see>.
            </summary>
            <param name="concept">
              The <see cref="T:Cybele.ConceptString`1"/> to convert.
            </param>
            <returns>
              A read-only, non-allocating view into the contents of <paramref name="concept"/>, or a
              default-constructed <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;char&gt;</see> if
              <paramref name="concept"/> is <see langword="null"/>.
            </returns>
            <seealso cref="P:Cybele.ConceptString`1.View"/>
        </member>
        <member name="M:Cybele.ConceptString`1.op_Explicit(Cybele.ConceptString{`0})~System.String">
            <summary>
              Converts a <see cref="T:Cybele.ConceptString`1"/> into a raw <see cref="T:System.String"/>.
            </summary>
            <param name="concept">
              The <see cref="T:Cybele.ConceptString`1"/> to convert.
            </param>
            <returns>
              The raw contents of <paramref name="concept"/>, or <see langword="null"/> if <paramref name="concept"/>
              is <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.#ctor(System.String)">
            <summary>
              Constructs a new <see cref="T:Cybele.ConceptString`1"/>.
            </summary>
            <param name="contents">
              The raw contents of the new <see cref="T:Cybele.ConceptString`1"/>.
            </param>
        </member>
        <member name="M:Cybele.ConceptString`1.Equals(Cybele.ConceptString{`0})">
            <summary>
              Determines whether this <see cref="T:Cybele.ConceptString`1"/> is equal to another
              <see cref="T:Cybele.ConceptString`1"/>.
            </summary>
            <param name="rhs">
              The <see cref="T:Cybele.ConceptString`1"/> against which to compare this one for equality.
            </param>
            <returns>
              <see langword="true"/> if this <see cref="T:Cybele.ConceptString`1"/> is equal to <paramref name="rhs"/>
              using an ordinal, case-sensitive comparison; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.Equals(System.Object)">
            <summary>
              Determines whether this <see cref="T:Cybele.ConceptString`1"/> is equal to another <see cref="T:System.Object"/>.
            </summary>
            <param name="rhs">
              The <see cref="T:System.Object"/> against which to compare this one for equality.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="rhs"/> is a <see cref="T:Cybele.ConceptString`1"/> that is equal
              to this <see cref="T:Cybele.ConceptString`1"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.CompareTo(Cybele.ConceptString{`0})">
            <summary>
              Determines the ordering of this <see cref="T:Cybele.ConceptString`1"/> relative to another in the overall
              total order.
            </summary>
            <param name="rhs">
              The <see cref="T:Cybele.ConceptString`1"/> against which to compare this one for relative ordering.
            </param>
            <returns>
              A negative integer if this <see cref="T:Cybele.ConceptString`1"/> comes before <paramref name="rhs"/> in
              the overall total order, <c>0</c> if this <see cref="T:Cybele.ConceptString`1"/> comes at the same
              position as <paramref name="rhs"/> in the overall total order, and a positive integer if this
              <see cref="T:Cybele.ConceptString`1"/> comes after <paramref name="rhs"/> in the overall total order.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.GetHashCode">
            <summary>
              Produces the hash code for this <see cref="T:Cybele.ConceptString`1"/>.
            </summary>
            <returns>
              A <c>32</c>-bit signed integer that is the hash code for this <see cref="T:Cybele.ConceptString`1"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.ToString">
            <summary>
              Produces a string representation of this <see cref="T:Cybele.ConceptString`1"/>.
            </summary>
            <returns>
              A string representation of this <see cref="T:Cybele.ConceptString`1"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.op_Equality(Cybele.ConceptString{`0},Cybele.ConceptString{`0})">
            <summary>
              Determines if two <see cref="T:Cybele.ConceptString`1">ConceptStrings</see> are equal.
            </summary>
            <param name="lhs">
              The first <see cref="T:Cybele.ConceptString`1"/>.
            </param>
            <param name="rhs">
              The second <see cref="T:Cybele.ConceptString`1"/>.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="lhs"/> is equal to <paramref name="rhs"/>; otherwise,
              <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.op_Inequality(Cybele.ConceptString{`0},Cybele.ConceptString{`0})">
            <summary>
              Determiens if two <see cref="T:Cybele.ConceptString`1">ConceptStrings</see> are not equal.
            </summary>
            <param name="lhs">
              The first <see cref="T:Cybele.ConceptString`1"/>.
            </param>
            <param name="rhs">
              The second <see cref="T:Cybele.ConceptString`1"/>.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="lhs"/> is not equal to <paramref name="rhs"/>; otherwise,
              <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.op_LessThan(Cybele.ConceptString{`0},Cybele.ConceptString{`0})">
            <summary>
              Determines if one <see cref="T:Cybele.ConceptString`1"/> is strictly less than another.
            </summary>
            <param name="lhs">
              The left-hand operand of the ordering relation.
            </param>
            <param name="rhs">
              The right-hand operand of the ordering relation.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="lhs"/> is strictly less than <paramref name="rhs"/>; otherwise,
              <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.op_GreaterThan(Cybele.ConceptString{`0},Cybele.ConceptString{`0})">
            <summary>
              Determines if one <see cref="T:Cybele.ConceptString`1"/> is strictly greater than another.
            </summary>
            <param name="lhs">
              The left-hand operand of the ordering relation.
            </param>
            <param name="rhs">
              The right-hand operand of the ordering relation.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="lhs"/> is strictly greater than <paramref name="rhs"/>;
              otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.op_LessThanOrEqual(Cybele.ConceptString{`0},Cybele.ConceptString{`0})">
            <summary>
              Determines if one <see cref="T:Cybele.ConceptString`1"/> is less than or equal to another.
            </summary>
            <param name="lhs">
              The left-hand operand of the ordering relation.
            </param>
            <param name="rhs">
              The right-hand operand of the ordering relation.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="lhs"/> is less than or equal to <paramref name="rhs"/>;
              otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.op_GreaterThanOrEqual(Cybele.ConceptString{`0},Cybele.ConceptString{`0})">
            <summary>
              Determines if one <see cref="T:Cybele.ConceptString`1"/> is greater than or equal to another.
            </summary>
            <param name="lhs">
              The left-hand operand of the ordering relation.
            </param>
            <param name="rhs">
              The right-hand operand of the ordering relation.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="lhs"/> is greater than or equal to <paramref name="rhs"/>;
              otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.GetEnumerator">
            <summary>
              Produces an enumerator that iterates over the characters in this <see cref="T:Cybele.ConceptString`1"/>.
            </summary>
            <returns>
              An enumerator that iterates over the characters in this <see cref="T:Cybele.ConceptString`1"/>.
            </returns>
        </member>
        <member name="M:Cybele.ConceptString`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
              Produces an enumerator that iterates over the characters in this <see cref="T:Cybele.ConceptString`1"/> in
              a type-erased manner.
            </summary>
            <returns>
              An enumerator that iterates over the characters in this <see cref="T:Cybele.ConceptString`1"/> in a
              type-erased manner.
            </returns>
        </member>
        <member name="P:Cybele.ConceptString`1.Contents">
            <value>
              The raw contents of this <see cref="T:Cybele.ConceptString`1"/>.
            </value>
        </member>
        <member name="T:Cybele.Extensions.EnumExtensions">
            <summary>
              A collection of methods that extend user-defined <see cref="T:System.Enum"/> types.
            </summary>
        </member>
        <member name="M:Cybele.Extensions.EnumExtensions.IsValid``1(``0)">
            <summary>
              Determines if an enumerator is valid.
            </summary>
            <typeparam name="TEnum">
              [deduced] The type of <paramref name="enumerator"/>.
            </typeparam>
            <param name="enumerator">
              The enumerator whose validity to determine.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="enumerator"/> is a valid enumerator; otherwise,
              <see langword="false"/>.
            </returns>
            <remarks>
              <para>
                This method is intended primarily as a defensive helper to ensure that enumerators provided to an API
                are among those that the author of the enumerator intended to be used. Because enums are simply type
                system wrappers around integers, it is legal to convert an arbitrary integer into a enumeration even
                if no name was assigned to that value in the enumeration's declaration. Passing such a value to an API
                often implicitly violates preconditions, especially when <c>switch</c> statements are employed that
                assume an enumerator is one of the explicitly defined constants.
              </para>
              <para>
                When dealing with "regular" enums (as opposed to <see cref="T:System.FlagsAttribute">"flag"</see> enums), this
                method works identically to <see cref="M:System.Enum.IsDefined(System.Type,System.Object)"/>. Specifically, an enumerator of
                a "regular" enum is valid if and only if its value is that of one of the named constants in the enum's
                declaration. This is not affected by enumeration aliasing (i.e. having more than one named constant
                for the same value).
              </para>
              <para>
                When dealing with a <see cref="T:System.FlagsAttribute">"flag"</see> enum, the behavior of this method diverges
                from that of <see cref="M:System.Enum.IsDefined(System.Type,System.Object)"/> to provide a response that is more in line with
                most users' expectations. An enumerator of a <see cref="T:System.FlagsAttribute">"flag"</see> enum is valid if
                and only if its value is a combination of one or more of the named constants in the enum's declaration.
                This means that un-aliased combinations will be treated as valid by this method, whereas
                <see cref="M:System.Enum.IsDefined(System.Type,System.Object)"/> recognizes only those values specified in the enum's
                declaration. Note that <see cref="T:System.FlagsAttribute">"flag"</see> enums do not receive a <c>None</c>
                enumerator automatically; as such, an enumerator with numeric value <c>0</c> is only valid if such a
                constant is explicitly defined by the enumeration.
              </para>
            </remarks>
        </member>
        <member name="M:Cybele.Extensions.EnumExtensions.AsInt64``1(``0)">
            <summary>
              Reinterprets the bit pattern of the numeric value of an enumerator as the bit pattern for a <c>64</c>-bit
              signed integer (i.e. a <see cref="T:System.Int64"/>).
            </summary>
            <typeparam name="TEnum">
              [deduced] The type of <paramref name="enumerator"/>.
            </typeparam>
            <param name="enumerator">
              The enumerator whose bit pattern to reinterpret.
            </param>
            <returns>
              A <see cref="T:System.Int64"/> whose bit pattern is the same as the bit pattern of <paramref name="enumerator"/>,
              possibly with some extra leading <c>0</c>s.
            </returns>
        </member>
    </members>
</doc>
